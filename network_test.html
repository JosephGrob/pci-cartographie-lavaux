<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>R√©seau d'acteurs ‚Äì Lavaux</title>
  <script type="text/javascript" src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <link href="https://unpkg.com/vis-network@9.1.2/styles/vis-network.min.css" rel="stylesheet" type="text/css" />

  <!-- Leaflet pour les cartes dans les noeuds -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }
    #network {
      width: 100%;
      height: 600px;
      border: 1px solid #ccc;
      border-radius: 10px;
    }
    #main-container {
      display: flex;
      align-items: flex-start;
      gap: 20px;
    }

    #info-panel {
      padding: 10px;
      border: 1px solid #ccc;
      background-color: #f8f8f8;
      border-radius: 6px;
      height: 580px;
      overflow-y: auto;
      width: 30%;
      min-width: 250px;
      display: none;
    }




    pre {
      font-size: 0.85em;
      background-color: #f0f0f0;
      padding: 10px;
      border-radius: 4px;
    }
    .faded {
      opacity: 0.8 !important;
    }

    #main-container {
      display: flex;
      align-items: flex-start;
      gap: 20px;
    }


    .meta-details {
      font-size: 0.95em;
      line-height: 1.5;
    }

    .meta-field {
      margin-bottom: 10px;
    }

    .meta-value {
      margin-left: 10px;
      color: #333;
    }

    .meta-desc {
      margin-left: 10px;
      color: #777;
      font-size: 0.85em;
    }


    #toggle-actor-list {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    #toggle-actor-list:hover {
      background-color: #2980b9;
    }


    #actor-list {
      list-style: none;
      padding-left: 0;
      margin-top: 10px;
    }

    .actor-entry {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      gap: 10px;
    }

    .actor-entry button {
      background-color: #ecf0f1;
      border: 1px solid #bdc3c7;
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s ease;
    }

    .actor-entry button:hover {
      background-color: #d6eaf8;
    }


    h1 {
      text-align: center;
      font-size: 2em;
      color: #2c3e50;
      margin-bottom: 20px;
    }

    #legend-container {
      position: fixed;
      top: 120px;
      right: 26px;
      max-width: 400px;
      z-index: 1000;
      background: #fff;
      padding: 10px 15px;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      font-size: 85%;
    }

    @media screen and (max-width: 600px) {
      #legend-container {
        top: auto;
        bottom: 10px;
        right: 10px;
        left: 10px;
        max-width: calc(100% - 20px);
        font-size: 85%;
      }
    }



    



  </style>
</head>
<body>

  
<header style="text-align: center; margin-bottom: 50px;">
  <h1 style="font-size: 2.4em; color: #2c3e50; margin-bottom: 10px;">
    R√©seau d'acteurs li√© au savoir-faire traditionnel (entretien et construction) des murs de vigne √† Lavaux
  </h1>

  <div style="margin-bottom: 20px; text-align: center; margin-top: 30px;">
    <div style="display: inline-flex; gap: 12px; flex-wrap: wrap;">
      <button id="toggle-actor-list" style="background-color: #3498db; color: white; border: none; padding: 10px 16px; border-radius: 6px; font-size: 15px; cursor: pointer;">
        üìÇ R√©pertoire des acteurs
      </button>

      <button id="reset-view" style="background-color: #5d6d7e; color: white; border: none; padding: 10px 16px; border-radius: 6px; font-size: 15px; cursor: pointer;">
        üîÑ R√©initialiser la vue/recentrer
      </button>

      <button id="toggle-map" style="background-color: #27ae60; color: white; border: none; padding: 10px 16px; border-radius: 6px; font-size: 15px; cursor: pointer;">
        üó∫Ô∏è Afficher la carte
      </button>

      <button id="toggle-network-map" style="background-color: #8e44ad; color: white; border: none; padding: 10px 16px; border-radius: 6px; font-size: 15px; cursor: pointer;">
        R√©seau + carte
      </button>
    </div>


    <div id="legend-container">

      <strong>L√©gende</strong><br>
      <div style="margin-top: 6px; line-height: 1.8;">
        <div><span style="display:inline-block;width:12px;height:12px;background:#3498db;border-radius:50%;margin-right:6px;"></span>Acteur¬∑rice / Entit√©</div>
        <div><span style="display:inline-block;width:12px;height:12px;background:#e67e22;border-radius:50%;margin-right:6px;"></span>Lieu associ√© au PCI</div>
        
        <div>
          <svg width="40" height="10" style="vertical-align: middle; margin-right: 6px;">
            <defs>
              <marker id="arrowhead-grey" markerWidth="6" markerHeight="4" refX="6" refY="2" orient="auto" markerUnits="userSpaceOnUse">
                <polygon points="0 0, 6 2, 0 4" fill="#2c3e50" />
              </marker>
            </defs>
            <line x1="0" y1="2" x2="30" y2="2" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead-grey)" />
          </svg>
          Liens sociaux (relations entre individus/entit√©s)
        </div>

        <div>
          <svg width="40" height="10" style="vertical-align: middle; margin-right: 6px;">
            <defs>
              <marker id="arrowhead-orange" markerWidth="6" markerHeight="4" refX="6" refY="2" orient="auto" markerUnits="userSpaceOnUse">
                <polygon points="0 0, 6 2, 0 4" fill="#e67e22" />
              </marker>
            </defs>
            <line x1="0" y1="2" x2="30" y2="2" stroke="#e67e22" stroke-width="2" stroke-dasharray="4,2" marker-end="url(#arrowhead-orange)" />
          </svg>
          Lien au territoire (relations au territoire)
        </div>
      </div>
    </div>

  </div>


  <p style="font-style: italic; color: #555;">
    Ce graphe est g√©n√©r√© automatiquement √† partir des r√©ponses enregistr√©es dans Baserow.
  </p>

  <p style="font-style: italic; color: #444;">
  Cliquez sur un n≈ìud ou un lien dans le r√©seau ou sur la carte pour explorer les informations associ√©es : 
  d√©tails sur une entit√©, anecdotes de collaboration ou souvenirs li√©s √† un lieu.
  </p>

  </header>

  <!-- R√©pertoire des acteurs (d√©pliable) -->
  <div id="actor-list-container" style="max-height: 0; overflow: hidden; transition: max-height 0.4s ease;">
    <ul id="actor-list" style="padding-left: 20px; list-style: none; margin-top: 10px;"></ul>
  </div>

  <!-- Bloc commun pour carte OU r√©seau -->
  <div id="main-container" style="display: flex; gap: 20px; margin-top: 10px;">
    <div id="leaflet-map" style="flex: 2; height: 600px; display: none; border: 1px solid #ccc; border-radius: 10px;"></div>
    <div id="network" style="flex: 2;"></div>
    <div id="info-panel" style="display: none; position: relative;">
      <button id="close-info-panel" style="
        position: absolute;
        top: 8px;
        right: 8px;
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        color: #999;
      " title="Fermer">‚úñ</button>
      <div id="info-content">Cliquez sur un n≈ìud pour voir les d√©tails</div>
    </div>


  </div>






  

  <script>

    let nodesMap = new Map(); 
    let data; // ‚Üê rendre global


    function findSimilarNode(nom, age, nodesMap) {
      for (const [id, node] of nodesMap.entries()) {
        if (node.label !== nom) continue;

        const nodeAge = node.meta?.age?.[0]?.value;
        if (!nodeAge || isNaN(nodeAge)) continue;

        const nodeAgeInt = parseInt(nodeAge, 10);
        const inputAgeInt = parseInt(age, 10);

        if (!isNaN(inputAgeInt) && Math.abs(nodeAgeInt - inputAgeInt) <= 1) {
          return id; 
        }
      }

      return null; 
    }

    let edges = []; 
    let options; 
    let leafletZones = new Map();



    async function buildNetwork() {
      const TOKEN = "oF4ZhbO62oPoeUpVVrbjCuf8s3Jaxe3v";
      const TABLE_ID = "510775";
      const API_URL = `https://api.baserow.io/api/database/rows/table/${TABLE_ID}/?user_field_names=true`;

      const response = await fetch(API_URL, {
        headers: { Authorization: `Token ${TOKEN}` }
      });
      const result = await response.json();
      const rows = result.results;


      
      const roleLabels = {
        pratique: "pratique",
        etudie: "√©tudie",
        lesdeux: "√©tudie et pratique",
        temoin: "t√©moigne"
      };

      function updateNodeData(node, updates, isAuthor = false) {
        for (const key in updates) {
          const value = updates[key];

          if (value === undefined || value === null) continue;

          // Initialiser le champ s‚Äôil n‚Äôexiste pas
          if (!node.meta[key]) node.meta[key] = [];

          // Cas sp√©cial : champ media (tableau d'objets)
          if (key === "fichier_media" && Array.isArray(value)) {
            value.forEach(media => {
              if (!media?.url) return;
              const alreadyExists = node.meta[key].some(item => item.url === media.url);
              if (!alreadyExists) {
                node.meta[key].push(media);
              }
            });
            continue; 
          }

          //Autres champs texte classiques (string)
          if (typeof value !== "string" || value.trim() === "") continue;

          // Si auteur principal : supprimer les doublons venant de "collab"
          if (isAuthor) {
            node.meta[key] = node.meta[key].filter(item => {
              return item.source !== "collab" || item.value !== value;
            });
          }

          const alreadyExists = node.meta[key].some(item => item.value === value);
          if (!alreadyExists) {
            node.meta[key].push({
              value: value,
              source: isAuthor ? "author" : "collab"
            });
          }
        }
      }


      rows.forEach(row => {
        const author = row.nom?.trim();
        const authorType = row.type;
        console.log("fichier_media pour", row.nom, ":", row.fichier_media);
        const role = row.role;
        let resolvedAuthorId; 

  

        // ---- Auteur principal
        if (author) {
          resolvedAuthorId = findSimilarNode(author, row.age, nodesMap) || author;

          if (!nodesMap.has(resolvedAuthorId)) {
            nodesMap.set(resolvedAuthorId, {
              id: resolvedAuthorId,
              label: author,
              group: authorType,
              meta: {}
            });
          }

          updateNodeData(nodesMap.get(resolvedAuthorId), {
            type: row.type,
            age: row.age,
            metier: row.metier,
            user_lieu_lat: row.user_lieu_lat,
            user_lieu_lon: row.user_lieu_lon,

            user_lieu: row.user_lieu,
            memoire: row.memoire,
            evenement: row.evenement,
            fichier_media: row.fichier_media,
            memoire_zones: row.memoire_zones,
            memoire_points: row.memoire_points
          }, true); 

        }

        // ---- Collaborateur
        const collab = row.collab_nom?.trim();
        const collabType = row.collab_type;


        let dynCollabs = [];

        try {
          if (typeof row.collaborations_dynamiques === "string") {
            dynCollabs = JSON.parse(row.collaborations_dynamiques);
          } else if (Array.isArray(row.collaborations_dynamiques)) {
            dynCollabs = row.collaborations_dynamiques;
          }
        } catch (e) {
          console.warn("Impossible de parser collaborations_dynamiques :", e);
        }


        // On stocke la liste des collaborations dynamiques dans les m√©tadonn√©es du n≈ìud auteur
        if (resolvedAuthorId && dynCollabs.length > 0) {
          const authorNode = nodesMap.get(resolvedAuthorId);
          if (authorNode) {
            // On initialise le champ s‚Äôil n‚Äôexiste pas
            if (!authorNode.meta.collaborations_dynamiques) {
              authorNode.meta.collaborations_dynamiques = [];
            }

            // Ajoute les √©l√©ments dynamiques s‚Äôils ne sont pas d√©j√† pr√©sents
            dynCollabs.forEach(entry => {
              const exists = authorNode.meta.collaborations_dynamiques.some(e => e.nom === entry.nom && e.description === entry.description);
              if (!exists) {
                authorNode.meta.collaborations_dynamiques.push(entry);
              }
            });
          }
        }


        if (Array.isArray(dynCollabs)) {
          dynCollabs.forEach(c => {
            const cName = c.nom?.trim();
            if (!cName) return;

            const resolvedDynCollabId = findSimilarNode(cName, c.age, nodesMap) || cName;

            if (!nodesMap.has(resolvedDynCollabId)) {
              nodesMap.set(resolvedDynCollabId, {
                id: resolvedDynCollabId,
                label: cName,
                group: c.type,
                meta: {}
              });
            }

            updateNodeData(nodesMap.get(resolvedDynCollabId), {
              type: c.type,
              age: c.age,
              metier: c.metier,
              collab_lieu: c.lieu,
              collab_implication: c.implication,
              collab_lieu_lat: c.lat,
              collab_lieu_lon: c.lon,
              annee: c.annee,
              membres: c.membres,
              activites: c.activites,
              nb_personnes: c.nb_personnes,
              liens: c.liens,
              ages_famille: c.ages_famille,
              collab_autre: c.autre
            }, false);


            edges.push({
              from: resolvedAuthorId,
              to: resolvedDynCollabId,
              label: "collabore avec",
              title: c.description || "",
              color: { color: "#2c3e50" }
            });
          });
        }




        if (collab) {
          let resolvedCollabId = findSimilarNode(collab, row.collab_age, nodesMap) || collab;

          if (!nodesMap.has(resolvedCollabId)) {
            nodesMap.set(resolvedCollabId, {
              id: resolvedCollabId,
              label: collab,
              group: collabType,
              meta: {}
            });
          }

          const extraCollabData = {
            type: collabType,
            age: row.collab_age,
            metier: row.collab_metier,
            collab_lieu: row.collab_lieu,
            collab_implication: row.collab_implication,
            label: collab,
            annee: row.collab_annee,
            membres: row.collab_membres,
            activites: row.collab_activites,
            nb_personnes: row.collab_nb_personnes,
            liens: row.collab_liens,
            ages_famille: row.collab_ages_famille,
            collab_autre: row.collab_autre,
            collab_lieu_lat: row.collab_lieu_lat,
            collab_lieu_lon: row.collab_lieu_lon
          };

          updateNodeData(nodesMap.get(resolvedCollabId), extraCollabData, false);

          edges.push({
            from: resolvedAuthorId,
            to: resolvedCollabId,
            label: "collabore avec",
            title: row.collab_description || "",
            color: { color: "#2c3e50" }
          });
        }


        // ---- Zone(s)
        const zones = row.zones_geojson;
        const labelTexte = roleLabels[role] || "a renseign√©";

        if (zones && zones.length > 0 && author) {
          try {
            const geojson = JSON.parse(zones);
            const zoneLabelsByIndex = [
              "a appris (apprend)",        // index 0 = apprentissage
              "a transmis (transmets)",      // index 1 = transmission
              "a pratiqu√© (pratique)",      // index 2 = pratique
              "a √©tudi√© (√©tudie)",        // index 3 = √©tude
              "a des informations"        // index 4 = information (si pr√©sent)
            ];

            geojson.forEach((feature, index) => {
              const zoneId = `${author}-zone-${index}`;

              // On r√©cup√®re le type r√©el de la zone (ajout√© pr√©c√©demment dans le formulaire)
              const zoneType = feature.properties?.zoneType;

              const zoneLabelsByType = {
                apprentissage: "a appris (apprend)",
                transmission: "a transmis (transmet)",
                pratique: "a pratiqu√© (pratique)",
                etudie: "a √©tudi√© (√©tudie)",
                information: "a des informations"
              };

              const edgeLabel = zoneLabelsByType[zoneType] || "li√© √† cette zone";

              nodesMap.set(zoneId, {
                id: zoneId,
                label: "Lieu",
                group: "zone",
                title: "Cliquez pour voir la carte",
                geojson: feature,
                name:
                  typeof feature.properties?.zone === "string"
                    ? feature.properties.zone.toLowerCase().trim()
                    : ""

              });


              edges.push({
                from: resolvedAuthorId,
                to: zoneId,
                label: edgeLabel,
                dashes: true,
                color: { color: "#e67e22" },
                memoire_zones: row.memoire_zones,     // tableau brut
                memoire_points: row.memoire_points // cha√Æne JSON ou tableau
              });

            });

          } catch (e) {
            console.error("Erreur de parsing GeoJSON :", e);
          }
        }
      });


      const keyLabels = {
        // R√©pondants
        type: ["Type d‚Äôacteur", ""],
        nom: ["Nom", ""],
        age: ["√Çge", ""],
        metier: ["M√©tier", "Profession ou activit√© principale"],
        user_lieu: ["Lieu", "Lieu de r√©sidence ou d'activit√©"],
        user_lieu_lat: ["Latitude", "Latitude du lieu"],
        user_lieu_lon: ["Longitude", "Longitude du lieu"],
        nb_personnes: ["Nombre de personnes", "Taille du groupe ou de la famille"],
        liens: ["Liens", "Relations entre membres"],
        ages_famille: ["√Çges d√©taill√©s", "√Çges des membres"],
        annee: ["Ann√©e de cr√©ation", "Date de d√©but d'activit√©"],
        membres: ["Nombre de membres", "Combien de membres contient l'entit√©"],
        activites: ["Activit√©s", "Activit√©s exerc√©es"],
        role: ["R√¥le dans le PCI", "Relation √† ce savoir-faire"],
        memoire: ["Souvenirs, r√©cits, anecdotes ou perceptions li√©s √† ce savoir-faire", "Texte libre"],
        evenement: ["Transformation(s) du savoir-faire observ√©e(s) au fil du temps", "Texte libre"],
        transmission_intention: ["Volont√©/souhait de transmettre (ou non) ce savoir-faire", "Oui/non"],

        // Collaborateurs (√©quivalents)
        collab_type: ["Type", ""],
        collab_nom: ["Nom", ""],
        collab_description: ["Souvenir partag√©", "Anecdote ou souvenir en lien avec la collaboration"],
        collab_lieu: ["Lieu", "Lieu de r√©sidence ou d'activit√©"],
        collab_lieu_lat: ["Latitude", "Latitude du lieu"],
        collab_lieu_lon: ["Longitude", "Longitude du lieu"],
        collab_age: ["√Çge", ""],
        collab_metier: ["M√©tier", "Profession ou activit√© principale"],
        collab_implication: ["Implication PCI", "Quelle implication dans le savoir-faire"],
        collab_nb_personnes: ["Nombre de personnes", "Taille du groupe ou famille"],
        collab_liens: ["Liens entre personnes", "Relations entre membres"],
        collab_ages_famille: ["√Çges des membres", "√Çges d√©taill√©s"],
        collab_annee: ["Ann√©e de cr√©ation", "D√©but d'activit√©"],
        collab_membres: ["Nombre de membres", "Combien de membres impliqu√©s"],
        collab_activites: ["Activit√©s", "Activit√©s exerc√©es"],
        collab_autre: ["Autres pr√©cisions", "Sp√©cificit√©s si type = autre"],

        // Zones m√©moire
        memoire_zones: ["Souvenir li√© √† une zone", ""],
        memoire_points: ["Souvenir li√© √† un point", ""]
      };


      function generateCustomDetails(meta, type) {
        if (!meta) return "<em>Aucune information disponible</em>";

        const allKeys = Object.keys(meta).sort();
        let output = `<div class="meta-details">`;

        for (const key of allKeys) {
          if (key === "type") continue;
          if (["memoire_points", "memoire_zones"].includes(key)) continue; //

          const list = meta[key];
          if (!list || list.length === 0) continue;

          const [label, description] = keyLabels[key] || [key, ""];
          let valueHtml = "";
          if (key === "memoire_points") {
            try {
              const anecdotes = list.map(entry => {
                if (typeof entry === "string") entry = JSON.parse(entry);
                return entry.texte;
              }).filter(Boolean);
              valueHtml = anecdotes.map(txt => `<div style="margin-bottom: 6px;">üìå ${txt}</div>`).join("");
            } catch (e) {
              valueHtml = "<em>Format non lisible</em>";
            }
          } else if (key === "fichier_media") {
            valueHtml = list.map(entry => {
              const url = entry.url;
              if (!url) return "";

              const extension = url.split('.').pop().toLowerCase();

              if (["jpg", "jpeg", "png", "gif", "webp"].includes(extension)) {
                return `<img src="${url}" alt="${entry.visible_name || "image"}" style="max-width: 100%; margin: 10px 0; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.1);" />`;
              } else if (["mp4", "webm", "ogg"].includes(extension)) {
                return `<video controls style="max-width:100%; margin: 10px 0; border-radius: 6px;"><source src="${url}" type="video/${extension}">Votre navigateur ne supporte pas la vid√©o.</video>`;
              } else if (["mp3", "wav", "ogg"].includes(extension)) {
                return `<audio controls style="width:100%; margin: 10px 0;"><source src="${url}" type="audio/${extension}">Votre navigateur ne supporte pas l'audio.</audio>`;
              } else {
                return `<a href="${url}" target="_blank" style="margin: 10px 0; display: inline-block;">üìé ${entry.visible_name || "Fichier"}</a>`;
              }
            }).join("<br>");
          } else {
            valueHtml = list.map(entry => entry.value).join("<br>");
          }

          output += `
            <div class="meta-field">
              <strong>${label}:</strong><br>
              <div class="meta-value">${valueHtml}</div>
              ${description ? `<div class="meta-desc"><em>${description}</em></div>` : ""}
            </div><hr>
          `;
        }

        output += `</div>`;
        return output;
      }









      // Cr√©er les noeuds avec les infos combin√©es
      const nodes = Array.from(nodesMap.values()).map(node => {
        const meta = node.meta || {};
        const formatField = key => {
          const list = meta[key];
          if (!list || list.length === 0) return "Non renseign√©";
          return list.map(entry => `${entry.value}`).join("<br>");
        };



        // on stocke les m√©tadonn√©es compl√®tes ici
        node.details = generateCustomDetails(meta, node.group);



        return node;
      });


      
      const list = document.getElementById("actor-list");
      list.innerHTML = "";

      Array.from(nodesMap.values())
        .filter(n => n.group !== "zone")
        .sort((a, b) => a.label.localeCompare(b.label))
        .forEach(n => {
          const li = document.createElement("li");
          li.className = "actor-entry";
          li.innerHTML = `
            <span><strong>${n.label}</strong> <span style="color: #777;">(${n.group})</span></span>
            <button class="actor-btn" data-id="${n.id}">üìç Voir dans le r√©seau</button>
          `;
          const button = li.querySelector(".actor-btn");
          button.addEventListener("click", () => {
            const selectedId = button.dataset.id;
            console.log("Bouton cliqu√© :", selectedId);

            const allNodeIds = data.nodes.getIds();
            const allEdgeIds = data.edges.getIds();

            const connectedEdges = data.edges.get({
              filter: edge => edge.from === selectedId || edge.to === selectedId
            });

            const connectedNodeIds = new Set();
            connectedEdges.forEach(edge => {
              connectedNodeIds.add(edge.from);
              connectedNodeIds.add(edge.to);
            });

            allNodeIds.forEach(id => {
              const isConnected = connectedNodeIds.has(id);
              data.nodes.update({
                id: id,
                color: {
                  ...data.nodes.get(id).color,
                  opacity: isConnected ? 1 : 0.15
                }
              });
            });

            allEdgeIds.forEach(id => {
              const edge = data.edges.get(id);
              const isConnected = edge.from === selectedId || edge.to === selectedId;
              data.edges.update({
                id: id,
                color: {
                  ...edge.color,
                  opacity: isConnected ? 1 : 0.1
                }
              });
            });

          });

          list.appendChild(li);
        });


      const container = document.getElementById("network");
      data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };

      options = {
        nodes: {
          shape: "dot",
          size: 15,
          font: {
            size: 14,
            color: "#000000",
            face: "Arial"
          },
          borderWidth: 1
        },
        groups: {
          personne: { color: "#3498db" },
          famille: { color: "#3498db" },
          association: { color: "#3498db" },
          entreprise: { color: "#3498db" },
          collectif: { color: "#3498db" },
          commune: { color: "#3498db" },
          autre: { color: "#3498db" },
          zone: { color: "#f39c12" }
        },
        edges: {
          arrows: "to",
          font: { align: "middle" }
        },
        physics: {
        solver: "forceAtlas2Based",
        forceAtlas2Based: {
          gravitationalConstant: -50,
          centralGravity: 0.01,
          springLength: 180, 
          springConstant: 0.04
        },
        stabilization: {
          iterations: 150
        }
      }
            };

      network = new vis.Network(container, data, options);

      // Ajout dynamique des boutons de zoom dans le conteneur r√©seau
      const zoomControls = document.createElement("div");
      zoomControls.id = "network-zoom-controls";
      zoomControls.style.cssText = `
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: white;
        border: 1px solid #ccc;
        border-radius: 6px;
        box-shadow: 0 1px 4px rgba(0,0,0,0.2);
        overflow: hidden;
      `;

      zoomControls.innerHTML = `
        <button onclick="zoomNetwork(1.2)" style="
          display: block;
          width: 30px;
          height: 30px;
          border: none;
          background: white;
          font-size: 18px;
          line-height: 1;
          cursor: pointer;
          border-bottom: 1px solid #ccc;
        ">+</button>
        <button onclick="zoomNetwork(0.8)" style="
          display: block;
          width: 30px;
          height: 30px;
          border: none;
          background: white;
          font-size: 18px;
          line-height: 1;
          cursor: pointer;
        ">‚àí</button>
      `;

      container.style.position = "relative"; // assure que le bouton s'aligne correctement
      container.appendChild(zoomControls);





      network.on("click", function (params) {
        const panel = document.getElementById("info-panel");
        if (ignoreNetworkBlink) {
          console.log("Clignotement r√©seau bloqu√© (clic venant du r√©seau)");
          ignoreNetworkBlink = false;
          return;
        }


        panel.style.display = "block";


        document.getElementById("info-panel").style.display = "block";


        if (params.nodes.length > 0) {
          const nodeId = params.nodes[0];
          const nodeData = nodesMap.get(nodeId);
          

          // Zoom sur la carte m√™me si _mapCoords ou _bounds ne sont pas encore d√©finis
          if (leafletMap && nodeData) {
            if (!nodeData._mapCoords && nodeData.meta) {
              const coords = getNodeCoords(nodeData.meta);
              if (coords) nodeData._mapCoords = coords;
            }

            if (!nodeData._bounds && nodeData.geojson) {
              try {
                nodeData._bounds = L.geoJSON(nodeData.geojson).getBounds();
              } catch (e) {
                console.warn("Impossible de calculer les bounds :", e);
              }
            }

            if (nodeData._mapCoords) {
              leafletMap.setView(nodeData._mapCoords, 15, { animate: true });
            } else if (nodeData._bounds) {
              leafletMap.fitBounds(nodeData._bounds, { padding: [20, 20] });
            }

            // Clignotement sur la carte
            const marker = leafletMarkers.get(nodeId);
            const zoneLayer = leafletZones.get(nodeId);
            blinkLeafletLayer(marker || zoneLayer);
          }
          

          if (nodeData.group === "zone" && nodeData.geojson) {
            const geojson = nodeData.geojson;
            document.getElementById("info-content").innerHTML = `
              <h3>Zone d‚Äô√©tude</h3>
              <div id="mini-map" style="height: 250px; border-radius: 6px; margin-top: 10px;"></div>
            `;
            setTimeout(() => {
              const map = L.map("mini-map").setView([46.5, 6.7], 13);
              L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: "&copy; OpenStreetMap contributors"
              }).addTo(map);
              L.geoJSON(geojson, {
                style: { color: "#e67e22", weight: 2 }
              }).addTo(map);
              map.fitBounds(L.geoJSON(geojson).getBounds());
            }, 50);
          } else {

            document.getElementById("info-content").innerHTML = `
              <h3>${nodeData.label}</h3>
              <p><strong>Type</strong>: ${nodeData.group}</p>
              <p><strong>D√©tails</strong>:<br>${nodeData.details}</p>
            `;
          }

          } else if (params.edges.length > 0) {
            const edgeId = params.edges[0];

            if (lockedEdges.has(edgeId)) {
              console.log("Ar√™te verrouill√©e pendant clignotement : AFFICHAGE quand m√™me autoris√©", edgeId);
              // NE PAS return ‚Üí on affiche quand m√™me les infos
            }

            console.log("Click sur ar√™te dans vis.js :", edgeId);

            // On ne clignote QUE dans Leaflet
            lockedEdges.add(edgeId);
            console.log("Edge locked (juste carte) :", edgeId);
            blinkOnlyLeafletLine(edgeId);

            const edgeData = data.edges.get(edgeId);
            const fromNode = nodesMap.get(edgeData.from);
            const toNode = nodesMap.get(edgeData.to);

            const zoneNode = [fromNode, toNode].find(n => n.group === "zone");
            const zoneMetaId = zoneNode?.geojson?.properties?.id_meta;

            if (zoneMetaId) {
              let memoireZones = [];
              let memoirePoints = [];

              // Parsing s√©curis√© des souvenirs li√©s aux zones
              try {
                const rawZones = edgeData.memoire_zones;
                memoireZones = Array.isArray(rawZones) ? rawZones : JSON.parse(rawZones);
              } catch (e) {
                console.warn("Erreur de parsing pour memoire_zones :", e);
              }

              // Parsing s√©curis√© des souvenirs li√©s aux points
              try {
                const rawPoints = edgeData.memoire_points;
                memoirePoints = Array.isArray(rawPoints) ? rawPoints : JSON.parse(rawPoints);
              } catch (e) {
                console.warn("Erreur de parsing pour memoire_points :", e);
              }

              // Filtrer les souvenirs correspondant √† la zone cliqu√©e
              const zonesMatch = memoireZones.filter(m => m.id_meta === zoneMetaId && m.texte?.trim());
              const pointsMatch = memoirePoints.filter(m => m.id_meta === zoneMetaId && m.texte?.trim());

              // Affichage console
              console.log(`Souvenirs ZONES pour ${zoneMetaId} :`, zonesMatch.map(z => z.texte));
              console.log(`Souvenirs POINTS pour ${zoneMetaId} :`, pointsMatch.map(p => p.texte));
            }



            if (zoneNode && zoneNode.geojson) {
              console.log("GeoJSON complet de la zone :", zoneNode.geojson);
            }


            const fromMeta = fromNode?.meta || {};
            const toMeta = toNode?.meta || {};

            const fromLabel = fromNode?.label || edgeData.from;
            const toLabel = toNode?.label || edgeData.to;

            const isZoneLink = fromLabel === "Lieu" || toLabel === "Lieu" || toLabel.includes("zone");

            // Zoom carte
            const fromCoords = fromNode?._mapCoords || fromNode?._center;
            const toCoords = toNode?._mapCoords || toNode?._center;
            if (leafletMap && fromCoords && toCoords) {
              const bounds = L.latLngBounds([fromCoords, toCoords]);
              leafletMap.fitBounds(bounds, { padding: [40, 40] });
            }

            if (isZoneLink) {
              const relation = edgeData.label || "lien au territoire";

              let contextSentence = "Souvenir(s), perception(s), anecdote(s) li√©(s) √† ce lieu :";
              if (relation.includes("appris")) contextSentence = "‚Ä¶ li√©(s) √† l‚Äôapprentissage du savoir-faire :";
              else if (relation.includes("transmis")) contextSentence = "‚Ä¶ li√©(s) √† la transmission du savoir-faire :";
              else if (relation.includes("pratiqu√©")) contextSentence = "‚Ä¶ dans le cadre de la pratique du savoir-faire :";
              else if (relation.includes("√©tudi√©")) contextSentence = "‚Ä¶ dans le cadre de l‚Äô√©tude ou de la recherche :";
              else if (relation.includes("information")) contextSentence = "Information(s) que l‚Äôacteur souhaite partager √† propos de ce lieu :";

              const zoneNode = [fromNode, toNode].find(n => n.group === "zone");
              const zoneMetaId = zoneNode?.geojson?.properties?.id_meta;

              let memoireZones = [], memoirePoints = [];
              try {
                const rawZones = edgeData.memoire_zones;
                memoireZones = Array.isArray(rawZones) ? rawZones : JSON.parse(rawZones);
              } catch (e) {
                console.warn("Erreur de parsing memoire_zones :", e);
              }

              try {
                const rawPoints = edgeData.memoire_points;
                memoirePoints = Array.isArray(rawPoints) ? rawPoints : JSON.parse(rawPoints);
              } catch (e) {
                console.warn("Erreur de parsing memoire_points :", e);
              }

              const zonesMatch = memoireZones.filter(m => m.id_meta === zoneMetaId && m.texte?.trim());
              const pointsMatch = memoirePoints.filter(m => m.id_meta === zoneMetaId && m.texte?.trim());

              let memoireHtml = "";

              if (zonesMatch.length > 0 || pointsMatch.length > 0) {
                memoireHtml += `<div style="margin-top: 10px;"><strong>${contextSentence}</strong><br>`;
                zonesMatch.forEach(z => {
                  memoireHtml += `<div style="margin-bottom: 6px;"> ${z.texte.trim()}</div>`;
                });
                pointsMatch.forEach(p => {
                  memoireHtml += `<div style="margin-bottom: 6px;">üìç ${p.texte.trim()}</div>`;
                });
                memoireHtml += `</div>`;
              } else {
                memoireHtml += `<em>Aucune anecdote ou souvenir renseign√© pour ce lieu.</em>`;
              }

              // Affichage final
              document.getElementById("info-content").innerHTML = `
                <h3>Lien au territoire ou √† l‚Äôespace</h3>
                <p><strong>Acteur :</strong> ${fromLabel}</p>
                <p><strong>Type de relation au lieu :</strong> ${relation.charAt(0).toUpperCase() + relation.slice(1)} le savoir-faire</p>
                ${memoireHtml}
              `;

            } else {
              // Collaboration
              const actor = fromMeta.nom?.[0]?.value || fromLabel;
              const collab = toMeta.collab_nom?.[0]?.value || toLabel;

              const implication = toMeta.collab_implication?.[0]?.value || "";
              let anecdote = "";

              let dyn = fromMeta.collaborations_dynamiques || [];
              try {
                if (typeof dyn === "string") dyn = JSON.parse(dyn);
                if (Array.isArray(dyn)) {
                  const match = dyn.find(d => d.nom === collab);
                  if (match?.description) anecdote = match.description;
                }
              } catch (e) {
                console.warn("Erreur parsing collaborations_dynamiques", e);
              }

              document.getElementById("info-content").innerHTML = `
                <h3>Collaboration entre acteurs</h3>
                <p><strong>Acteur principal :</strong> ${actor}</p>
                <p><strong>Collaborateur :</strong> ${collab}</p>
                ${implication ? `<p><strong>Implication :</strong> ${implication}</p>` : ""}
                ${anecdote ? `<p><strong>Anecdote :</strong><br>${anecdote}</p>` : "<p><em>Aucune anecdote renseign√©e.</em></p>"}
              `;
            }
          }





        if (params.nodes.length === 0 && params.edges.length === 0) {
          data.nodes.getIds().forEach(id => {
            network.body.nodes[id].setOptions({ opacity: 1 });
          });
          data.edges.getIds().forEach(id => {
            network.body.edges[id].setOptions({ opacity: 1 });
          });
          leafletMarkers.forEach(marker => {
            marker.setStyle({ fillOpacity: 0.8, opacity: 1 });
          });
          leafletLines.forEach(line => {
            line.setStyle({ opacity: 0.7 });
          });
          document.getElementById("info-panel").style.display = "none";
        }


      });

      console.log("Boutons acteurs ajout√©s, mise en place des √©v√©nements...");

      document.addEventListener("click", function (e) {
        console.log("CLIC ACTEUR d√©tect√© (document listener)");

        const btn = e.target.closest(".actor-btn");
        if (!btn) return;

        const selectedId = btn.dataset.id;
        console.log("ID s√©lectionn√© :", selectedId);

        const isCarteSeule =
          document.getElementById("leaflet-map").style.display === "block" &&
          document.getElementById("network").style.display === "none";
        console.log("Mode actif :", isCarteSeule ? "Carte SEULE" : "Autre mode (r√©seau ou mixte)");

        // R√©cup√®re les ar√™tes directement reli√©es AU SEUL n≈ìud cliqu√©
        const directlyConnectedEdges = data.edges.get({
          filter: edge => edge.from === selectedId || edge.to === selectedId
        });
        console.log(" Ar√™tes li√©es :", directlyConnectedEdges);

        const directlyConnectedNodeIds = new Set([selectedId]);
        directlyConnectedEdges.forEach(edge => {
          directlyConnectedNodeIds.add(edge.from);
          directlyConnectedNodeIds.add(edge.to);
        });
        console.log("N≈ìuds connect√©s :", Array.from(directlyConnectedNodeIds));

        // R√©seau (vis.js)
        console.log(" Mise √† jour du r√©seau (vis.js)...");
        data.nodes.getIds().forEach(id => {
          const node = network.body.nodes[id];
          if (node) {
            node.setOptions({ opacity: directlyConnectedNodeIds.has(id) ? 1 : 0.05 });
          }
        });

        data.edges.getIds().forEach(id => {
          const edge = data.edges.get(id);
          const isDirect = edge.from === selectedId || edge.to === selectedId;
          const edgeInVis = network.body.edges[id];
          if (edgeInVis) {
            if (lockedEdges.has(id)) {
              console.log("Ar√™te verrouill√©e pendant clignotement : mise √† jour visuelle ignor√©e", id);
              return;
            }
            edgeInVis.setOptions({
              color: {
                color: edge.color?.color || "#999",
                opacity: isDirect ? 1 : 0.05
              },
              font: {
                color: isDirect ? "#000" : "rgba(0,0,0,0)"
              }
            });
          }
        });


        // Carte
        console.log("Mise √† jour des marqueurs...");
        console.log("Carte affich√©e ? ", leafletMap && leafletMap._container?.style.display);
        leafletMarkers.forEach((marker, id) => {
          const isDirect = directlyConnectedNodeIds.has(id);
          console.log("Marker modifi√© :", id, "‚Üí", marker);
          marker.setStyle({
            fillOpacity: isDirect ? 0.8 : 0.05,
            opacity: isDirect ? 1 : 0.05
          });
        });

        console.log("Mise √† jour des zones...");
        leafletZones.forEach((geoLayer, zoneId) => {
          const isDirect = directlyConnectedNodeIds.has(zoneId);
          console.log("Zone modifi√©e :", zoneId, "‚Üí", geoLayer);
          geoLayer.setStyle({
            fillOpacity: isDirect ? 0.2 : 0.01,
            opacity: isDirect ? 1 : 0.05
          });
        });

        console.log(" Mise √† jour des lignes...");
        leafletLines.forEach((line, key) => {
          const parts = key.split("-");
          const from = parts[1];
          const to = parts[2];
          const isDirect = (from === selectedId || to === selectedId);
          line.setStyle({
            opacity: isDirect ? 0.7 : 0.05
          });
        });
      });




      document.getElementById("reset-view").addEventListener("click", () => {
        // R√©initialiser la carte Leaflet
        leafletMarkers.forEach(marker => {
          marker.setStyle({ fillOpacity: 0.8, opacity: 1 });
        });
        leafletZones.forEach(zone => {
          zone.setStyle({ fillOpacity: 0.2, opacity: 1 });
        });
        leafletLines.forEach(line => {
          line.setStyle({ opacity: 0.7 });
        });

        // R√©initialiser le r√©seau (vis.js)
        Object.values(network.body.nodes).forEach(node => {
          node.setOptions({ opacity: 1 });
        });
        Object.entries(network.body.edges).forEach(([id, edge]) => {
          if (lockedEdges.has(id)) {
            console.log(" Ar√™te verrouill√©e pendant clignotement : reset ignor√©", id);
            return;
          }
          edge.setOptions({
            color: {
              color: edge.options.color?.color || "#999",
              opacity: 1
            },
            font: {
              color: "#000"
            }
          });
        });


        // Recentrer automatiquement le graphe si tu veux :
        network.fit({
          animation: {
            duration: 500,
            easingFunction: "easeInOutQuad"
          }
        });

        // Recentrer la carte si elle est active
        if (leafletMap && markersLayer && leafletMap._container.style.display !== "none") {
          const bounds = markersLayer.getBounds();
          if (bounds.isValid()) {
            leafletMap.fitBounds(bounds, { padding: [20, 20] });
          }
        }

        // Nettoyer le panneau d‚Äôinfo
        const panel = document.getElementById("info-panel");
        document.getElementById("info-content").innerHTML = "Cliquez sur un n≈ìud pour voir les d√©tails";
        document.getElementById("info-panel").style.display = "none";

      });




      document.getElementById("close-info-panel").addEventListener("click", () => {
        document.getElementById("info-panel").style.display = "none";
      });

      document.getElementById("close-info-panel").addEventListener("click", () => {
        const panel = document.getElementById("info-panel");
        panel.style.display = "none";

        const mapDiv = document.getElementById("leaflet-map");
        const isMapVisible = mapDiv.style.display === "block";

        if (isMapVisible && leafletMap && markersLayer) {
          // Recentrer la CARTE
          const bounds = markersLayer.getBounds();
          if (bounds.isValid()) {
            leafletMap.fitBounds(bounds, { padding: [20, 20] });
          }
        } else {
          // Recentrer le R√âSEAU
          if (network && typeof network.fit === "function") {
            network.fit({
              animation: {
                duration: 500,
                easingFunction: "easeInOutQuad"
              }
            });
          }
        }
      });


    }


    buildNetwork();
    function getNodeCoords(meta) {
      const lat = meta.user_lieu_lat?.[0]?.value || meta.collab_lieu_lat?.[0]?.value;
      const lon = meta.user_lieu_lon?.[0]?.value || meta.collab_lieu_lon?.[0]?.value;
      if (lat && lon) return [parseFloat(lat), parseFloat(lon)];
      return null;
    }





    let leafletMap;
    let markersLayer;
    let leafletMarkers = new Map();
    let leafletLines = new Map();
    let ignoreNetworkBlink = false;
    let blinkingEdges = new Set();
    let blinkingLeafletLines = new Set();
    let lockedEdges = new Set();  // ‚Üê Ar√™tes temporairement "verrouill√©es"






    function initLeafletMap() {
        // Nettoyage
      if (leafletMap) {
        leafletMap.remove();
        document.getElementById("leaflet-map").innerHTML = "";
      }

      document.getElementById("info-panel").style.display = "none";
      document.getElementById("info-content").innerHTML = "Cliquez sur un n≈ìud pour voir les d√©tails";

      leafletMap = L.map("leaflet-map").setView([46.5, 6.7], 12);
      L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(leafletMap);

      leafletMap.on("zoomend", adjustLeafletElementsSize);

      markersLayer = L.featureGroup().addTo(leafletMap);
      leafletMarkers.clear();
      leafletLines.clear();
    }


    function populateLeafletMap() {
      markersLayer.clearLayers();
      leafletMarkers.clear();
      leafletLines.clear();
      leafletZones.clear();

      // Ajout des marqueurs (personnes, entit√©s)
      Array.from(nodesMap.values()).forEach(node => {
        const coords = getNodeCoords(node.meta || {});
        if (!coords) return;

        const color = options.groups[node.group]?.color || "#3498db";

        const marker = L.circleMarker(coords, {
          radius: 8,
          color: color,
          fillColor: color,
          fillOpacity: 0.8,
          weight: 1
        })
          .bindPopup(`<strong>${node.label}</strong><br>Type : ${node.group}`)
          .addTo(markersLayer);

        marker.on('click', () => {
          const panel = document.getElementById("info-panel");
          panel.style.display = "block";

          ignoreNetworkBlink = true;

          blinkNetworkNode(node.id);

          if (node.group === "zone" && node.geojson) {
            const geojson = node.geojson;
            document.getElementById("info-content").innerHTML = `
              <h3>Zone d‚Äô√©tude</h3>
              <div id="mini-map" style="height: 250px; border-radius: 6px; margin-top: 10px;"></div>
            `;
            setTimeout(() => {
              const map = L.map("mini-map").setView([46.5, 6.7], 13);
              L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: "&copy; OpenStreetMap contributors"
              }).addTo(map);
              L.geoJSON(geojson, {
                style: { color: "#e67e22", weight: 2 }
              }).addTo(map);
              map.fitBounds(L.geoJSON(geojson).getBounds());
            }, 50);
          } else {
            document.getElementById("info-content").innerHTML = `
              <h3>${node.label}</h3>
              <p><strong>Type</strong>: ${node.group}</p>
              <p><strong>D√©tails</strong>:<br>${node.details}</p>
            `;
          }
        });

        leafletMarkers.set(node.id, marker);
        node._mapCoords = coords;
      });

      // Zones (polygones ou points)
      Array.from(nodesMap.values()).forEach(node => {
        if (node.group !== "zone" || !node.geojson) return;
        if (["centrale", "tampon"].includes(node.name || "")) return;

        const geometryType = node.geojson.geometry?.type;

        if (geometryType === "Point") {
          const coords = [
            node.geojson.geometry.coordinates[1],
            node.geojson.geometry.coordinates[0]
          ];

          const marker = L.circleMarker(coords, {
            radius: 8,
            color: "#e67e22",
            fillColor: "#e67e22",
            fillOpacity: 0.8,
            weight: 1
          })
            .bindPopup(`<strong>${node.label}</strong>`)
            .addTo(markersLayer);

          marker.on('click', () => {
            document.getElementById("info-panel").style.display = "block";

            ignoreNetworkBlink = true;

            blinkNetworkNode(node.id);
            document.getElementById("info-content").innerHTML = `
              <h3>Zone d‚Äô√©tude</h3>
              <div id="mini-map" style="height: 250px; border-radius: 6px; margin-top: 10px;"></div>
            `;
            setTimeout(() => {
              const map = L.map("mini-map").setView(coords, 14);
              L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: "&copy; OpenStreetMap contributors"
              }).addTo(map);
              L.circleMarker(coords, {
                radius: 8,
                color: "#e67e22",
                fillColor: "#e67e22",
                fillOpacity: 0.8,
                weight: 1
              }).addTo(map);
            }, 50);
          });

          leafletMarkers.set(node.id, marker);
          node._mapCoords = coords;
          node._center = coords; 
          node._bounds = L.latLngBounds([coords]); 

        } else {
          const geoLayer = L.geoJSON(node.geojson, {
            style: {
              color: "#e67e22",
              weight: 2,
              fillOpacity: 0.2
            }
          })
            .bindPopup(`<strong>${node.label}</strong>`)
            .addTo(markersLayer);

          geoLayer.on('click', () => {
            const geojson = node.geojson;
            document.getElementById("info-panel").style.display = "block";
            document.getElementById("info-content").innerHTML = `
              <h3>Zone d‚Äô√©tude</h3>
              <div id="mini-map" style="height: 250px; border-radius: 6px; margin-top: 10px;"></div>
            `;

            setTimeout(() => {
              const map = L.map("mini-map").setView([46.5, 6.7], 13);
              L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: "&copy; OpenStreetMap contributors"
              }).addTo(map);
              L.geoJSON(geojson, {
                style: { color: "#e67e22", weight: 2 }
              }).addTo(map);
              map.fitBounds(L.geoJSON(geojson).getBounds());
            }, 50);
            ignoreNetworkBlink = true;
            blinkNetworkNode(node.id);
          });

          node._bounds = geoLayer.getBounds();
          node._center = geoLayer.getBounds().getCenter();
          leafletZones.set(node.id, geoLayer);
        }

      });


      // Lignes entre n≈ìuds (r√©seau sur la carte)
      edges.forEach(edge => {
        const fromNode = nodesMap.get(edge.from);
        const toNode = nodesMap.get(edge.to);

        const fromCoords = fromNode?._mapCoords || fromNode?._center;
        const toCoords = toNode?._mapCoords || toNode?._center;

        if (!fromCoords || !toCoords) return;

        const isZoneLink = fromNode.group === "zone" || toNode.group === "zone";
        const keyPrefix = isZoneLink ? "zone" : "edge";
        const key = `${keyPrefix}-${edge.from}-${edge.to}`;

        const line = L.polyline([fromCoords, toCoords], {
          color: edge.color?.color || "#555",
          weight: 2,
          opacity: 0.7,
          dashArray: edge.dashes ? "4" : null
        })
          .bindTooltip(edge.label || "Lien")
          .addTo(markersLayer);

        leafletLines.set(key, line);

        line.on("click", () => {
          console.log("Ligne Leaflet cliqu√©e :", key);

          const matchingEdgeId = data.edges.getIds().find(id => {
            const edgeData = data.edges.get(id);
            return edgeData.from === edge.from && edgeData.to === edge.to;
          });

          if (!matchingEdgeId) {
            console.warn("Aucune ar√™te r√©seau trouv√©e pour", edge.from, "‚Üí", edge.to);
            return;
          }

          ignoreNetworkBlink = true;
          blinkOnlyNetworkEdge(matchingEdgeId);

          const edgeData = data.edges.get(matchingEdgeId);
          const fromNode = nodesMap.get(edgeData.from);
          const toNode = nodesMap.get(edgeData.to);

          const zoneNode = [fromNode, toNode].find(n => n.group === "zone");
          const zoneMetaId = zoneNode?.geojson?.properties?.id_meta;

          const panel = document.getElementById("info-panel");
          panel.style.display = "block";

          if (zoneNode && zoneNode.geojson) {
            console.log("GeoJSON complet de la zone :", zoneNode.geojson);
          }

          const fromMeta = fromNode?.meta || {};
          const toMeta = toNode?.meta || {};

          const fromLabel = fromNode?.label || edgeData.from;
          const toLabel = toNode?.label || edgeData.to;

          const isZoneLink = fromLabel === "Lieu" || toLabel === "Lieu" || toLabel.includes("zone");

          // Zoom carte
          const fromCoords = fromNode?._mapCoords || fromNode?._center;
          const toCoords = toNode?._mapCoords || toNode?._center;
          if (leafletMap && fromCoords && toCoords) {
            const bounds = L.latLngBounds([fromCoords, toCoords]);
            leafletMap.fitBounds(bounds, { padding: [40, 40] });
          }

          if (isZoneLink) {
            const relation = edgeData.label || "lien au territoire";

            let contextSentence = "Souvenir(s), perception(s), anecdote(s) li√©(s) √† ce lieu :";
            if (relation.includes("appris")) contextSentence = "‚Ä¶ li√©(s) √† l‚Äôapprentissage du savoir-faire :";
            else if (relation.includes("transmis")) contextSentence = "‚Ä¶ li√©(s) √† la transmission du savoir-faire :";
            else if (relation.includes("pratiqu√©")) contextSentence = "‚Ä¶ dans le cadre de la pratique du savoir-faire :";
            else if (relation.includes("√©tudi√©")) contextSentence = "‚Ä¶ dans le cadre de l‚Äô√©tude ou de la recherche :";
            else if (relation.includes("information")) contextSentence = "Information(s) que l‚Äôacteur souhaite partager √† propos de ce lieu :";

            let memoireZones = [], memoirePoints = [];
            try {
              const rawZones = edgeData.memoire_zones;
              memoireZones = Array.isArray(rawZones) ? rawZones : JSON.parse(rawZones);
            } catch (e) {}
            try {
              const rawPoints = edgeData.memoire_points;
              memoirePoints = Array.isArray(rawPoints) ? rawPoints : JSON.parse(rawPoints);
            } catch (e) {}

            const zonesMatch = memoireZones.filter(m => m.id_meta === zoneMetaId && m.texte?.trim());
            const pointsMatch = memoirePoints.filter(m => m.id_meta === zoneMetaId && m.texte?.trim());

            let memoireHtml = "";

            if (zonesMatch.length > 0 || pointsMatch.length > 0) {
              memoireHtml += `<div style="margin-top: 10px;"><strong>${contextSentence}</strong><br>`;
              zonesMatch.forEach(z => {
                memoireHtml += `<div style="margin-bottom: 6px;"> ${z.texte.trim()}</div>`;
              });
              pointsMatch.forEach(p => {
                memoireHtml += `<div style="margin-bottom: 6px;">üìç ${p.texte.trim()}</div>`;
              });
              memoireHtml += `</div>`;
            } else {
              memoireHtml += `<em>Aucune anecdote ou souvenir renseign√© pour ce lieu.</em>`;
            }

            document.getElementById("info-content").innerHTML = `
              <h3>Lien au territoire ou √† l‚Äôespace</h3>
              <p><strong>Acteur :</strong> ${fromLabel}</p>
              <p><strong>Type de relation au lieu :</strong> ${relation.charAt(0).toUpperCase() + relation.slice(1)} le savoir-faire</p>
              ${memoireHtml}
            `;

          } else {
            const actor = fromMeta.nom?.[0]?.value || fromLabel;
            const collab = toMeta.collab_nom?.[0]?.value || toLabel;
            const implication = toMeta.collab_implication?.[0]?.value || "";
            let anecdote = "";

            let dyn = fromMeta.collaborations_dynamiques || [];
            try {
              if (typeof dyn === "string") dyn = JSON.parse(dyn);
              if (Array.isArray(dyn)) {
                const match = dyn.find(d => d.nom === collab);
                if (match?.description) anecdote = match.description;
              }
            } catch (e) {}

            document.getElementById("info-content").innerHTML = `
              <h3>Collaboration entre acteurs</h3>
              <p><strong>Acteur principal :</strong> ${actor}</p>
              <p><strong>Collaborateur :</strong> ${collab}</p>
              ${implication ? `<p><strong>Implication :</strong> ${implication}</p>` : ""}
              ${anecdote ? `<p><strong>Anecdote :</strong><br>${anecdote}</p>` : "<p><em>Aucune anecdote renseign√©e.</em></p>"}
            `;
          }
        });






      });

      // Centrage final de la carte
      const bounds = markersLayer.getBounds();
      if (bounds.isValid()) {
        leafletMap.fitBounds(bounds, { padding: [20, 20] });
      }

      adjustLeafletElementsSize();
    }
    


    document.getElementById("toggle-map").addEventListener("click", () => {
      const mapDiv = document.getElementById("leaflet-map");
      const netDiv = document.getElementById("network");
      const toggleBtn = document.getElementById("toggle-map");

      const isVisible = mapDiv.style.display === "block";
      mapDiv.style.display = isVisible ? "none" : "block";
      netDiv.style.display = isVisible ? "block" : "none";

      toggleBtn.textContent = isVisible ? "Afficher la carte" : "Retour au r√©seau";

      if (isVisible) {
        setTimeout(() => {
          if (network && typeof network.redraw === "function") {
            network.redraw(); 
            network.fit({
              animation: {
                duration: 500,
                easingFunction: "easeInOutQuad"
              }
            });
          }
        }, 100);
      }

      if (!isVisible) {
        initLeafletMap();      
        populateLeafletMap();  
      }
    });



    document.getElementById("toggle-actor-list").addEventListener("click", () => {
      const container = document.getElementById("actor-list-container");
      const isOpen = container.style.maxHeight && container.style.maxHeight !== "0px";

      if (isOpen) {
        container.style.maxHeight = "0px";
      } else {
        // D√©plie selon la hauteur r√©elle
        container.style.maxHeight = container.scrollHeight + "px";
      }
    });

    document.getElementById("toggle-network-map").addEventListener("click", () => {
      const mapDiv = document.getElementById("leaflet-map");
      const netDiv = document.getElementById("network");

      // Affiche les deux
      mapDiv.style.display = "block";
      netDiv.style.display = "block";

      initLeafletMap();      
      populateLeafletMap();  


      // Centrer la carte
      const bounds = markersLayer.getBounds();
      if (bounds.isValid()) {
        leafletMap.fitBounds(bounds, { padding: [20, 20] });
      }

      // Centrer le r√©seau
      if (network && typeof network.fit === "function") {
        network.fit({
          animation: {
            duration: 500,
            easingFunction: "easeInOutQuad"
          }
        });
      }

      // Change le texte du bouton de carte
      document.getElementById("toggle-map").textContent = "üîÅ Retour au r√©seau";
    });

    function blinkLeafletLayer(layer, duration = 5000, interval = 500) {
      if (!layer) return;

      const isCircleMarker = layer instanceof L.CircleMarker;
      const isPolygon = layer instanceof L.Polygon || layer instanceof L.GeoJSON || layer.getBounds;

      let visible = true;
      let elapsed = 0;

      const originalStyle = layer.options || {};

      const blinkInterval = setInterval(() => {
        visible = !visible;
        elapsed += interval;

        if (isCircleMarker && layer.setStyle) {
          layer.setStyle({
            opacity: visible ? 1 : 0,
            fillOpacity: visible ? 0.8 : 0
          });
        } else if (isPolygon && layer.setStyle) {
          layer.setStyle({
            opacity: visible ? 1 : 0,
            fillOpacity: visible ? 0.2 : 0
          });
        } else {
          clearInterval(blinkInterval);
          return;
        }

        if (elapsed >= duration) {
          clearInterval(blinkInterval);
          layer.setStyle(originalStyle);
        }
      }, interval);
    }

    function blinkLeafletLine(edgeId, duration = 5000, interval = 500) {
      console.log("blinkLeafletLine appel√©e avec edgeId =", edgeId);

      const edge = network.body.edges[edgeId];
      if (!edge || !edge.options) {
        console.warn("edge introuvable dans network.body.edges pour ID :", edgeId);
        return;
      }

      if (lockedEdges.has(edgeId)) {
        console.log("edge d√©j√† verrouill√©e :", edgeId);
        return;
      }

      lockedEdges.add(edgeId);
      console.log("Edge verrouill√©e :", edgeId);

      const visEdge = network.body.edges[edgeId];
      const originalOptions = {
        color: visEdge.options.color,
        font: visEdge.options.font
      };

      let visible = true;
      let elapsed = 0;

      const blinkInterval = setInterval(() => {
        visible = !visible;
        elapsed += interval;

        visEdge.setOptions({
          color: {
            color: originalOptions.color.color,
            opacity: visible ? 1 : 0
          },
          font: {
            color: visible ? "#000" : "rgba(0,0,0,0)"
          }
        });

        if (elapsed >= duration) {
          clearInterval(blinkInterval);
          visEdge.setOptions(originalOptions);
          lockedEdges.delete(edgeId);
          console.log("Clignotement termin√©, edge d√©verrouill√©e :", edgeId);
        }
      }, interval);

      // V√©rification des coordonn√©es pour la carte (Leaflet)
      const edgeData = network.body.data.edges.get(edgeId);
      if (!edgeData) {
        console.warn("Aucune donn√©e pour cette edge dans data.edges :", edgeId);
        return;
      }

      const from = edgeData.from;
      const to = edgeData.to;
      console.log("edge connecte :", from, "‚Üí", to);

      const directKey = `edge-${from}-${to}`;
      const reverseKey = `edge-${to}-${from}`;
      const zoneDirectKey = `zone-${from}-${to}`;
      const zoneReverseKey = `zone-${to}-${from}`;

      const possibleKeys = [directKey, reverseKey, zoneDirectKey, zoneReverseKey];
      console.log("Tentatives de r√©cup√©ration des lignes Leaflet avec cl√©s :", possibleKeys);

      let line = null;
      for (const key of possibleKeys) {
        if (leafletLines.has(key)) {
          line = leafletLines.get(key);
          console.log("Ligne trouv√©e pour la cl√© :", key);
          break;
        }
      }

      if (!line) {
        console.warn("Aucune ligne Leaflet trouv√©e pour edgeId :", edgeId);
        return;
      }

      const blinkKey = directKey; // Juste pour √©viter doublons
      if (blinkingLeafletLines.has(blinkKey)) {
        console.log("Ligne d√©j√† en clignotement (Leaflet) :", blinkKey);
        return;
      }
      blinkingLeafletLines.add(blinkKey);

      const originalStyle = { ...line.options };
      let mapVisible = true;
      let mapElapsed = 0;

      const mapBlinkInterval = setInterval(() => {
        mapVisible = !mapVisible;
        mapElapsed += interval;
        line.setStyle({ opacity: mapVisible ? originalStyle.opacity : 0 });

        if (mapElapsed >= duration) {
          clearInterval(mapBlinkInterval);
          blinkingLeafletLines.delete(blinkKey);
          line.setStyle(originalStyle);
          console.log("Clignotement Leaflet termin√© pour :", blinkKey);
        }
      }, interval);
    }


    function adjustLeafletElementsSize() {
      const zoom = leafletMap.getZoom();

      // Tu peux ajuster ces limites selon ton go√ªt
      const baseRadius = 11;
      const minRadius = 7;
      const maxRadius = 18;

      const scaleFactor = Math.pow(0.9, zoom - 12); // Zoom 12 = base
      const adjustedRadius = Math.max(minRadius, Math.min(maxRadius, baseRadius / scaleFactor));

      // Met √† jour les marqueurs
      leafletMarkers.forEach(marker => {
        marker.setStyle({
          radius: adjustedRadius,
          weight: 1,
          fillOpacity: 0.8,
          opacity: 1
        });
      });

      // Met √† jour les lignes (liens)
      leafletLines.forEach(line => {
        const baseWeight = 3;
        const minWeight = 1;
        const maxWeight = 7;
        const adjustedWeight = Math.max(minWeight, Math.min(maxWeight, baseWeight / scaleFactor));

        line.setStyle({
          weight: adjustedWeight,
          opacity: 0.7
        });
      });
    }




    function blinkOnlyLeafletLine(edgeId, duration = 5000, interval = 500) {
      console.log(" blinkOnlyLeafletLine appel√©e pour", edgeId);

      const edgeData = data.edges.get(edgeId);
      if (!edgeData) {
        console.warn("Aucune ar√™te vis.js trouv√©e pour edgeId =", edgeId);
        return;
      }

      const from = edgeData.from;
      const to = edgeData.to;
      const lineKey = `edge-${from}-${to}`;
      const line = leafletLines.get(lineKey) || leafletLines.get(`zone-${from}-${to}`);

      if (!line) {
        console.warn("Aucune ligne Leaflet trouv√©e pour", lineKey);
        return;
      }

      if (blinkingLeafletLines.has(lineKey)) {
        console.log("Ligne Leaflet d√©j√† en clignotement :", lineKey);
        return;
      }

      blinkingLeafletLines.add(lineKey);
      const originalStyle = { ...line.options };
      let visible = true;
      let elapsed = 0;

      const mapBlinkInterval = setInterval(() => {
        visible = !visible;
        elapsed += interval;
        line.setStyle({ opacity: visible ? originalStyle.opacity : 0 });

        if (elapsed >= duration) {
          clearInterval(mapBlinkInterval);
          blinkingLeafletLines.delete(lineKey);
          line.setStyle(originalStyle);
          console.log("Fin du clignotement Leaflet :", lineKey);
        }
      }, interval);
    }



    function blinkLeafletLineOnly(lineKey, line, duration = 5000, interval = 500) {
      if (blinkingLeafletLines.has(lineKey)) return;

      blinkingLeafletLines.add(lineKey);
      const originalStyle = { ...line.options };
      let mapVisible = true;
      let elapsed = 0;

      const mapBlinkInterval = setInterval(() => {
        mapVisible = !mapVisible;
        elapsed += interval;
        line.setStyle({ opacity: mapVisible ? originalStyle.opacity : 0 });

        if (elapsed >= duration) {
          clearInterval(mapBlinkInterval);
          blinkingLeafletLines.delete(lineKey);
          line.setStyle(originalStyle);
        }
      }, interval);
    }

    
    function blinkNetworkNode(nodeId, duration = 5000, interval = 500) {
      const node = network.body.nodes[nodeId];
      if (!node) {
        console.warn("N≈ìud introuvable dans vis.js pour l'ID :", nodeId);
        return;
      }

      let visible = true;
      let elapsed = 0;

      const blinkInterval = setInterval(() => {
        visible = !visible;
        elapsed += interval;

        network.body.data.nodes.update({
          id: nodeId,
          opacity: visible ? 1 : 0
        });

        if (elapsed >= duration) {
          clearInterval(blinkInterval);
          network.body.data.nodes.update({
            id: nodeId,
            opacity: 1
          });
        }
      }, interval);
    }

    function blinkOnlyNetworkEdge(edgeId, duration = 4000, interval = 400) {
      const edge = data.edges.get(edgeId);
      if (!edge) {
        console.warn("Ar√™te non trouv√©e :", edgeId);
        return;
      }

      // Si d√©j√† en clignotement ‚Üí on ne relance que le clignotement carte
      if (lockedEdges.has(edgeId)) {
        console.log("Ar√™te d√©j√† verrouill√©e : on relance uniquement la carte :", edgeId);

        const from = edge.from;
        const to = edge.to;
        const lineKey = `edge-${from}-${to}`;
        const line = leafletLines.get(lineKey) || leafletLines.get(`zone-${from}-${to}`);
        if (line) blinkLeafletLineOnly(lineKey, line); // d√©finie ailleurs
        return;
      }

      // Lock
      lockedEdges.add(edgeId);
      blinkingEdges.add(edgeId);
      console.log("Edge locked:", edgeId);

      const originalEdge = { ...edge };
      let visible = true;
      let elapsed = 0;

      const blinkInterval = setInterval(() => {
        visible = !visible;
        elapsed += interval;

        data.edges.update({
          id: edgeId,
          color: {
            color: originalEdge.color?.color || "#999",
            opacity: visible ? 1 : 0
          },
          font: {
            color: visible ? "#000" : "rgba(0,0,0,0)"
          }
        });

        if (elapsed >= duration) {
          clearInterval(blinkInterval);
          blinkingEdges.delete(edgeId);
          lockedEdges.delete(edgeId);
          console.log("Edge unlocked:", edgeId);

          // Remise √† l'√©tat pr√©c√©dent (si l'ar√™te n‚Äôa pas √©t√© masqu√©e entre-temps)
          const current = data.edges.get(edgeId);
          if (current) {
            data.edges.update({
              id: edgeId,
              color: {
                color: originalEdge.color?.color || "#999",
                opacity: (current.color?.opacity === 0 || current.color?.opacity === 0.05) ? current.color.opacity : 1
              },
              font: {
                color: "#000"
              }
            });
          }
        }
      }, interval);

      // Lancer aussi le clignotement sur la carte
      const from = edge.from;
      const to = edge.to;
      const lineKey = `edge-${from}-${to}`;
      const line = leafletLines.get(lineKey) || leafletLines.get(`zone-${from}-${to}`);
      if (line) blinkLeafletLineOnly(lineKey, line);
    }


    function zoomNetwork(factor) {
      if (!network) return;
      const scale = network.getScale() * factor;
      const position = network.getViewPosition();
      network.moveTo({ position, scale, animation: true });
    }



  </script>

</body>
</html>